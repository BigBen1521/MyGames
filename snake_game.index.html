<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê°„ë‹¨í•œ ìŠ¤ë„¤ì´í¬ ê²Œì„</title>
    <style>
        /* ğŸ¨ CSS ìŠ¤íƒ€ì¼ë§ */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #333; /* ì–´ë‘ìš´ ë°°ê²½ */
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        .game-container {
            border: 5px solid #00ff00; /* ë„¤ì˜¨ ê·¸ë¦° í…Œë‘ë¦¬ */
            background-color: #000;
            padding: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
        }

        #gameCanvas {
            display: block;
            background-color: #222;
        }

        .game-info {
            width: 400px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 1.5em;
            color: #00ff00;
        }

        .game-info button {
            background-color: #00ff00;
            border: none;
            padding: 5px 10px;
            font-size: 1em;
            cursor: pointer;
            color: #000;
            font-weight: bold;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="game-info">
            <span>ì ìˆ˜: <span id="score">0</span></span>
            <button id="startButton">ê²Œì„ ì‹œì‘</button>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
    </div>

    <script>
        // ğŸ JavaScript ê²Œì„ ë¡œì§
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const startButton = document.getElementById('startButton');

        const gridSize = 20; // ê·¸ë¦¬ë“œ ì…€ í¬ê¸°
        const tileCount = canvas.width / gridSize;

        let snake = [];
        let dx = gridSize; // X ë°©í–¥ ì†ë„ (ì˜¤ë¥¸ìª½ ì‹œì‘)
        let dy = 0;        // Y ë°©í–¥ ì†ë„
        let food = {};
        let score = 0;
        let gameLoopInterval;
        let isGameOver = true;
        let changingDirection = false;

        // ê²Œì„ ì´ˆê¸° ìƒíƒœ ì„¤ì •
        function initializeGame() {
            snake = [
                { x: 6 * gridSize, y: 10 * gridSize },
                { x: 5 * gridSize, y: 10 * gridSize },
                { x: 4 * gridSize, y: 10 * gridSize }
            ];
            dx = gridSize;
            dy = 0;
            score = 0;
            scoreElement.textContent = score;
            isGameOver = false;
            changingDirection = false;
            placeFood();
            
            // ê¸°ì¡´ ì¸í„°ë²Œì´ ìˆìœ¼ë©´ ì œê±°í•˜ê³  ìƒˆë¡œ ì‹œì‘
            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameLoop, 150); // ë±€ ì†ë„ (150ms ë§ˆë‹¤ ì—…ë°ì´íŠ¸)
            startButton.textContent = "ë‹¤ì‹œ ì‹œì‘";
        }

        // ë¨¹ì´ ë¬´ì‘ìœ„ ë°°ì¹˜
        function placeFood() {
            let newFoodPos;
            do {
                newFoodPos = {
                    x: Math.floor(Math.random() * tileCount) * gridSize,
                    y: Math.floor(Math.random() * tileCount) * gridSize
                };
            } while (isFoodOnSnake(newFoodPos)); 
            food = newFoodPos;
        }

        // ë¨¹ì´ê°€ ë±€ ìœ„ì— ìˆëŠ”ì§€ í™•ì¸
        function isFoodOnSnake(pos) {
            return snake.some(segment => segment.x === pos.x && segment.y === pos.y);
        }

        // ë©”ì¸ ê²Œì„ ë£¨í”„
        function gameLoop() {
            if (isGameOver) return;
            changingDirection = false;

            if (checkCollision()) {
                endGame();
                return;
            }

            moveSnake();
            drawGame();
        }

        // ë±€ ì´ë™ ë° ë¨¹ì´ ì„­ì·¨
        function moveSnake() {
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // ë²½ í†µê³¼ (ìº”ë²„ìŠ¤ ê°€ì¥ìë¦¬ì—ì„œ ë°˜ëŒ€í¸ìœ¼ë¡œ ì´ë™)
            if (head.x < 0) head.x = canvas.width - gridSize;
            else if (head.x >= canvas.width) head.x = 0;
            else if (head.y < 0) head.y = canvas.height - gridSize;
            else if (head.y >= canvas.height) head.y = 0;

            snake.unshift(head); // ìƒˆ ë¨¸ë¦¬ ì¶”ê°€

            // ë¨¹ì´ ì„­ì·¨ í™•ì¸
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreElement.textContent = score;
                placeFood(); // ìƒˆ ë¨¹ì´ ë°°ì¹˜
                // ê¼¬ë¦¬ë¥¼ ì œê±°í•˜ì§€ ì•Šì•„ ë±€ ê¸¸ì´ê°€ ëŠ˜ì–´ë‚¨
            } else {
                snake.pop(); // ë¨¹ì§€ ì•Šì•˜ìœ¼ë©´ ê¼¬ë¦¬ ì œê±° (ì´ë™)
            }
        }

        // ì¶©ëŒ ê°ì§€ (ìì‹ ì˜ ëª¸í†µê³¼ ì¶©ëŒ)
        function checkCollision() {
            const head = snake[0];
            // ë¨¸ë¦¬ê°€ ëª¸í†µì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„(1ë²ˆ ì¸ë±ìŠ¤ë¶€í„°)ê³¼ ì¶©ëŒí•˜ëŠ”ì§€ í™•ì¸
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }

        // ê²Œì„ ì¢…ë£Œ
        function endGame() {
            isGameOver = true;
            clearInterval(gameLoopInterval);
            alert(`ê²Œì„ ì˜¤ë²„! ìµœì¢… ì ìˆ˜: ${score}`);
            startButton.textContent = "ë‹¤ì‹œ ì‹œì‘";
        }

        // ê²Œì„ ìš”ì†Œ ê·¸ë¦¬ê¸°
        function drawGame() {
            // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ë¨¹ì´ ê·¸ë¦¬ê¸° (ë¹¨ê°„ìƒ‰)
            ctx.fillStyle = 'red';
            ctx.fillRect(food.x, food.y, gridSize, gridSize);

            // ë±€ ê·¸ë¦¬ê¸° (ì´ˆë¡ìƒ‰)
            snake.forEach((segment, index) => {
                ctx.fillStyle = (index === 0) ? '#00ff00' : '#00cc00'; // ë¨¸ë¦¬ëŠ” ë°ê²Œ
                ctx.fillRect(segment.x, segment.y, gridSize, gridSize);
                
                // ê²½ê³„ì„  ì¶”ê°€ (ì„ íƒ ì‚¬í•­)
                ctx.strokeStyle = '#000';
                ctx.strokeRect(segment.x, segment.y, gridSize, gridSize);
            });
        }

        // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
        document.addEventListener('keydown', (event) => {
            if (changingDirection || isGameOver) return;
            changingDirection = true;

            const keyPressed = event.key;
            const goingUp = dy === -gridSize;
            const goingDown = dy === gridSize;
            const goingLeft = dx === -gridSize;
            const goingRight = dx === gridSize;

            // ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œì˜ ì¦‰ì‹œ ì „í™˜ ë°©ì§€
            if (keyPressed === 'ArrowLeft' && !goingRight) {
                dx = -gridSize; dy = 0;
            } else if (keyPressed === 'ArrowUp' && !goingDown) {
                dx = 0; dy = -gridSize;
            } else if (keyPressed === 'ArrowRight' && !goingLeft) {
                dx = gridSize; dy = 0;
            } else if (keyPressed === 'ArrowDown' && !goingUp) {
                dx = 0; dy = gridSize;
            }
        });

        // ì‹œì‘ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        startButton.addEventListener('click', initializeGame);

        // ì´ˆê¸° í™”ë©´ ê·¸ë¦¬ê¸°
        drawGame(); 
    </script>
</body>
</html>
